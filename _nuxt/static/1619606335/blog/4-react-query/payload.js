__NUXT_JSONP__("/blog/4-react-query", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C){return {data:[{page:{slug:"4-react-query",title:"React-query - biblioteka do zarządzanie danymi z API",date:"2021-04-18T21:50:21.000Z",toc:[{id:o,depth:g,text:p},{id:q,depth:g,text:r},{id:s,depth:g,text:t},{id:u,depth:g,text:v},{id:w,depth:g,text:x}],body:{type:"root",children:[{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Feasyontheweb.com\u002Fwhat-is-react-query-and-how-to-use-it\u002F",rel:[y,z,A],target:B},children:[{type:a,value:"Źródło artykułu"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    W tym artykule przyjrzymy się niesamowitej bibliotece o nazwie React-query i zobaczymy, czym jest react-query, dlaczego powinniśmy go używać w naszych aplikacjach React i oczywiście jak możemy go używać w naszych aplikacjach."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Pobieranie danych asynchronicznie i utrzymywanie ich w aplikacji React jest jedną z najbardziej frustrujących rzeczy do zrobienia, nawet jeśli na początku nie jest to trudne - sprawy komplikują się naprawdę szybko z pobieraniem danych i utrzymywaniem stanu pobranych danych."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Osobiście używałem Reduxa jako magazynu pamięci podręcznej dla pobieranych danych wcześniej i naprawdę nie było to przyjemne doświadczenie. React-query w tym sensie jest absolutnym ratunkiem, tak jak jego rodzeństwo react-table."}]},{type:a,value:c},{type:b,tag:h,props:{id:o},children:[{type:b,tag:f,props:{href:"#zalety-u%C5%BCywania-react-query",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:p}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Nie lubię pisać dużo blogów o poszczególnych bibliotekach, ale react-query szybko stał się jednym z moich ulubionych bibliotek wszech czasów i dlatego chciałbym podkreślić zalety react-query już na początku artykułu, abyście razem ze mną wsiedli do tego hype'owego pociągu."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Niektóre z zalet react-query to :"}]},{type:a,value:c},{type:b,tag:C,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Automatyczne buforowanie danych"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Automatyczne ponowne pobieranie świeżych danych po akcjach użytkownika"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Super czysta składnia"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Prefetching"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Używanie zbuforowanych danych"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Domyślne zarządzanie ładowaniem, stanem powodzenia i błędami"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Nieskończone zapytania"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Szczerze mówiąc, ta lista mogłaby się ciągnąć w nieskończoność i nie jest to nawet w zakresie tego artykułu, aby omówić każdy z tych punktów. Nie jest to również celem tego artykułu, celem jest uświadomienie Ci korzyści i dać Ci wgląd w możliwości, jakie daje nam react-query."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Aby zagłębić się i sprawdzić wszystko co daje react-query zawsze możesz zajrzeć do dokumentacji."}]},{type:a,value:c},{type:b,tag:h,props:{id:q},children:[{type:b,tag:f,props:{href:"#mniej-kodu",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:r}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:n,props:{alt:"kod",src:"https:\u002F\u002Fi2.wp.com\u002Feasyontheweb.com\u002Fwp-content\u002Fuploads\u002F2021\u002F01\u002Fcarbon-2021-01-12T170936.493.png?w=757&ssl=1"},children:[]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Jeśli  kiedykolwiek zdarzyło Ci się pisać kod taki jak ten, lub kod podobny do tego wewnątrz hooka (tak, wszyscy mądrzy), to react-query jest narzędziem dla Ciebie. Osobiście, nienawidzę używać stanów ładowania i błędów wszędzie - nawet jeśli napiszesz custom hooki, aby to zrobić, react-query oferuje o wiele więcej."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:n,props:{alt:"przykład react-query",src:"https:\u002F\u002Fi0.wp.com\u002Feasyontheweb.com\u002Fwp-content\u002Fuploads\u002F2021\u002F01\u002Fcarbon-2021-01-12T171357.638.png?w=749&ssl=1"},children:[]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    To jest refaktoryzowany kod wykorzystujący useQuery z react-query. Jedną z rzeczy, którą zauważysz bezpośrednio jest to, jak react-query zwraca isLoading, błąd i dane . Były to rzeczy, którymi musieliśmy zarządzać sami w pierwszej wersji kodu."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Wszystko co musisz zrobić to zaimportować hook useQuery z react-query i przekazać do niego trzy argumenty - unikalny klucz dla zapytania, funkcję, która jest faktycznym zapytaniem oraz opcjonalny obiekt config, który omówimy później."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    W ten sposób, react query zmniejsza całą masę kodu. A jeśli chodzi o kod, to im mniejsza powierzchnia kodu, tym mniejsze szanse na błędy."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Teraz, jeśli wyodrębnisz to również do hooka, voila! Jeszcze bardziej zmniejszyłeś swój kod. Ale zostawię to wam..."}]},{type:a,value:c},{type:b,tag:h,props:{id:s},children:[{type:b,tag:f,props:{href:"#dane-w-pami%C4%99ci-podr%C4%99cznej",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:t}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Jedną z największych zalet react-query jest mechanizm cache'owania i synchronizacji danych. Dzięki opcjom takim jak initialData, staleTime, cacheTime itd. jest to tak proste i wspaniałe do pracy"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Pomyślmy o tym, co normalnie dzieje się w aplikacji React, przechowywałbyś dane, które chcesz buforować w Reduxie lub jakimkolwiek innym globalnym mechanizmie zarządzania stanem, którego używasz, a za każdym razem, gdy wchodzisz do komponentu, najprawdopodobniej masz useEffect, w którym pobierasz nowe dane (lub nie, w oparciu o porównanie z danymi z pamięci podręcznej) i ponownie przechowujesz nowo pobrane dane w swoim globalnym stanie."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Jest to gorączkowe, zabugowane i nie daje zbyt wielu opcji (chyba, że sam je napiszesz, co znowu zwiększa powierzchnię kodu)."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Z react-query, wszystko to staje się proste. Wykorzystuje on koncepcję czegoś, co nazywa się stale danymi. Jeśli react-query widzi, że dane są stale, próbuje pobrać nowsze dane. Domyślnie czas stale wynosi 0, czyli dane stają się stale zaraz po ich pobraniu."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Pierwszą opcją, którą należy rozważyć jest czas stale, dłuższy czas stale, dłużej react-query będzie czekać zanim uzna zbuforowane dane za stale i spróbuje pobrać nowe dane."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Warto zauważyć, że react-query nie implementuje pollingu w żadnym sensie, zamiast tego używa aktywności użytkownika do wyzwalania następnej synchronizacji nieaktualnych danych."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Stałe zapytania są refetched automatycznie w tle, gdy:"}]},{type:a,value:c},{type:b,tag:C,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Montowane są nowe instancje zapytania"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Okno zostanie przeorientowane"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Sieć jest ponownie podłączona."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Opcjonalnie zapytanie może być skonfigurowane z interwałem refaktoryzacji."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Wszystko to jest konfigurowalne poprzez użycie refetchOnMount, refetchOnWindowFocus, refetchOnReconnect i refetchInterval."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Jeśli nie chcesz ciągle nasłuchiwać na aktywności użytkownika wymienione powyżej, możesz zwiększyć staleTime dla zapytania."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Jak odbywa się buforowanie danych? Buforowanie danych jest oparte na kombinacji klucz + funkcja zapytania, której używasz wewnątrz useQuery. Każda unikalna kombinacja jest używana do buforowania konkretnych danych."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Co więcej, nigdy nie będziesz musiał widzieć \"ładowania\" na ekranie, jeśli zapytanie zostało już raz uruchomione. Po tym, zbuforowane dane pojawią się na ekranie początkowo i zostaną zaktualizowane po zakończeniu synchronizacji. Zgrabne, prawda?"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Aby zrozumieć kompletny cykl życia buforowania, gorąco polecam zapoznać się z Przykładami Buforowania."}]},{type:a,value:c},{type:b,tag:h,props:{id:u},children:[{type:b,tag:f,props:{href:"#paginowane-zapytania",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:v}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:n,props:{alt:"koda do paginacji",src:"https:\u002F\u002Fi0.wp.com\u002Feasyontheweb.com\u002Fwp-content\u002Fuploads\u002F2021\u002F01\u002Fcarbon-2021-01-13T193333.872.png?w=715&ssl=1"},children:[]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Jak myślisz, co się stanie, kiedy mamy ten kawałek kodu i zmienimy numer strony? Niestety, to co się dzieje to fakt, że użytkownik widzi \"ładowanie\", tzn. zapytanie przechodzi w stan ładowania, a następnie w stan sukcesu przy każdej zmianie strony."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Dzieje się tak, ponieważ kombinacja klucz + queryFunction zmieniła się wraz ze zmianą numeru strony. Dlatego też react-query nie jest w stanie korzystać z buforowanych danych. Cóż, nawet bez react-query 99% aplikacji działa w ten sposób."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Z react-query masz jednak świetną opcję o nazwie keepPreviousData. Kiedy ta opcja jest ustawiona na true w obiekcie konfiguracyjnym, dane z poprzedniego zapytania są dostępne nawet kiedy zapytanie się zmienia i dane są zamieniane z nowymi danymi jak tylko nowe dane nadejdą. Jest to lepsze doświadczenie użytkownika, ponieważ nie musi on oglądać komunikatu o ładowaniu raz po raz."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Aby dowiedzieć się więcej na temat zapytań paginowanych sprawdź to -\u003E Zapytania paginowane."}]},{type:a,value:c},{type:b,tag:h,props:{id:w},children:[{type:b,tag:f,props:{href:"#mutacje",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:x}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    useQuery jest hookiem, którego używaliśmy do tej pory, useQuery jest jednak używany tylko dla zapytań GET. Co z zapytaniami aktualizującymi takimi jak PUT\u002FDELETE\u002FPOST? Co react-query ma dla nas podczas pracy z tymi zapytaniami?"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Tak jak hook useQuery, react-query dostarcza nam kolejny fajny hook o nazwie useMutation.\n"},{type:b,tag:n,props:{alt:"Oficjalny przykład useMutation z docs",src:"https:\u002F\u002Fi2.wp.com\u002Feasyontheweb.com\u002Fwp-content\u002Fuploads\u002F2021\u002F01\u002Fcarbon-2021-01-13T195053.313.png?w=765&ssl=1"},children:[]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Składnia useMutation jest nieco bardziej złożona w porównaniu do useQuery. Sam hook useMutation przyjmuje jako argumenty funkcję oraz obiekt konfiguracyjny (zauważ, że nie ma tutaj klucza)."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Aby jednak wywołać metodę mutacji, należy użyć metody mutation.mutate z argumentem, który ma być przekazany do funkcji użytej wewnątrz useMutation."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Wszystkie stany, które były dostępne dla nas w useQuery jak error, isLoading, isSuccess etc są dostępne również dla mutacji."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Mutacje posiadają również metody callback, które mogą być użyte w obiekcie konfiguracyjnym dla hooka useMutation. Jedną z najczęściej używanych kombinacji jest ta z onSuccess i invalidateQueries."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    react-query pozwala nam na unieważnienie dowolnego lub wszystkich zapytań i ich zbuforowanych danych. Przyjrzyjmy się teraz bardzo powszechnemu scenariuszowi - dodajemy nowy rekord do bazy danych za pomocą hooka useMutation, w prawie 95% przypadków to co chcielibyśmy następnie zrobić, to pobrać wszystkie rekordy ponownie, tak aby nowy zaktualizowany rekord został wyświetlony. Aby to zrobić, możemy użyć funkcjonalności invalidateQueries."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Kiedy unieważniamy jakieś zapytanie, pomyśl o tym, że usuwamy zbuforowane dane dla tego zapytania i ponownie pobieramy dane dla tego zapytania i przechowujemy je w globalnym cache'u.\n"},{type:b,tag:n,props:{alt:"Oficjalny przykład useMutation z invalidateQueries",src:"https:\u002F\u002Fi2.wp.com\u002Feasyontheweb.com\u002Fwp-content\u002Fuploads\u002F2021\u002F01\u002Fcarbon-2021-01-13T200033.095.png?resize=768%2C305&ssl=1"},children:[]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"    Zauważ, że w tym przykładzie unieważniamy dane dla dwóch konkretnych zapytań - todos i reminders, a zatem react-query automatycznie uruchomi hook useQuery dla tych dwóch zapytań i ponownie pobierze i ustawi nowe dane."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"autor "},{type:b,tag:f,props:{href:"https:\u002F\u002Feasyontheweb.com\u002Fabout-sahil-thakur\u002F",rel:[y,z,A],target:B},children:[{type:a,value:"Sahil Thakur"}]}]}]},dir:"\u002Fblog",path:"\u002Fblog\u002F4-react-query",extension:".md",createdAt:"2021-03-13T16:57:27.550Z",updatedAt:"2021-04-28T10:32:00.075Z"}}],fetch:{},mutations:void 0}}("text","element","\n","p","li","a",3,"h3","true",-1,"span","icon","icon-link","img","zalety-używania-react-query","Zalety używania react-query","mniej-kodu","Mniej kodu","dane-w-pamięci-podręcznej","Dane w pamięci podręcznej","paginowane-zapytania","Paginowane zapytania","mutacje","Mutacje","nofollow","noopener","noreferrer","_blank","ul")));